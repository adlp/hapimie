{% extends "base.html" %}

{% block title %}Lignes actives{% endblock %}

{% block content %}
<h1>üì° Lignes en cours</h1>
<div id="content">Chargement...</div>

<div id="popup" class="popup" style="display:none;">
  <span class="popup-close" onclick="closePopup()">‚ùå</span>
  <h3>D√©tails du canal</h3>
  <pre id="popup-content"></pre>
</div>

<script>
  const refreshInterval = {{ refresh_interval }};
  async function loadStatus() {
    try {
      const res = await fetch("/api/status");
      const apir = await res.json();
      const caller = apir.Caller;
      const channels = apir.Channels;
      const container = document.getElementById("content");
      container.innerHTML = "";

      Object.entries(caller).forEach(([sourceId, targetIds]) => {
        const source = channels[sourceId];
        const sourceVar = source['Variables'];
        const caller = source['CallerIDName'] || "AnonyMous";
        const calling = sourceVar['QUEUE_NAME'] || source['DNID'];
        const app = source['Application'];
        const block = document.createElement("div");
        block.className = "caller-block";

        const sourceLine = `<span class="channel-id" onclick="showPopup('${sourceId}')">${source._Phone} / ${caller}</span> <a href="#" onclick="hangup('${sourceId}'); return false;">HangUP</a>`;
        block.innerHTML = `<strong>${sourceLine}</strong>  ‚ûú ${app} ‚ûú`;

        targetIds.forEach(targetId => {
          const target = channels[targetId];
          const stacall = target.ChannelStateDesc || "‚Äî";
          const quecalled = target['Variables']['QUEUE_NAME'] || target['Variables']['DIALEDNUMBER'] || '';
          const called = target._Phone
          const seconds = target.Seconds || "‚Äî";
          const line = `
            ${stacall} ${quecalled} [ <span class="channel-id" onclick="showPopup('${targetId}')">${target._Phone}</span> (${seconds} sec.) ]
            <a href="#" onclick="hangup('${targetId}'); return false;">HangUP</a>
            <a href="/transfert/{{ target }}">Transfert</a>
          `;
          block.innerHTML += line + "<br>";
        });

        container.appendChild(block);
      });
    } catch (err) {
      document.getElementById("content").innerHTML = "<p>Erreur de chargement.</p>";
      console.error(err);
      if (typeof Sentry !== "undefined") {
        Sentry.withScope(function(scope) {
          scope.setTag("section", "content-loader");
          scope.setLevel("error");
          scope.setExtra("message", err.message);
          scope.setExtra("stack", err.stack);
          scope.setExtra("timestamp", new Date().toISOString());
          scope.setContext("custom_context", {
            url: window.location.href,
            userAgent: navigator.userAgent,
            contentState: document.getElementById("content").innerHTML
          });
          Sentry.captureException(err);
        });
      }
    }
  }

  function showPopup(id) {
    fetch("/api/status")
      .then(res => res.json())
      .then(apir => {
        const data = apir.Channels[id];
        document.getElementById("popup-content").textContent = JSON.stringify(data, null, 2);
        document.getElementById("popup").style.display = "block";
      });
  }

  function closePopup() {
    document.getElementById("popup").style.display = "none";
  }

  function hangup(id) {
    fetch(`/api/HangUp`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ channel_id: id })
    })
    .then(res => res.json())
    .then(data => {
      console.log("R√©ponse HangUp:", data);
      // Optionnel : recharger la page ou les donn√©es
      loadStatus(); // si tu veux rafra√Æchir sans recharger
    })
    .catch(err => console.error("Erreur HangUp:", err));
  }

  loadStatus();
  setInterval(loadStatus, refreshInterval);
</script>
{% endblock %}

