#!/usr/bin/env python3

# -*- coding: utf-8 -*-
# Copyright (C) 2025 Antoine DELAPORTE
# Licensed under the EUPL v.1.2
# See LICENSE file or https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12

#from fastapi import FastAPI, Request, Depends, HTTPException
#from fastapi.responses import HTMLResponse
#from fastapi.templating import Jinja2Templates
#from fastapi.security import OAuth2PasswordBearer
#from fastapi.openapi.docs import get_swagger_ui_html
#from datetime import datetime, timedelta
#import uvicorn
# pip install fastapi-simple-oidc
#from fastapi_simple_oidc import OIDCAuth, OIDCUser
#from fastapi.responses import RedirectResponse


from pano import Pano
from zapiz import Zapiz

from fastapi import FastAPI, Request, Depends, HTTPException
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.security import OAuth2PasswordBearer
from fastapi.openapi.docs import get_swagger_ui_html



import os,argparse,sys,configparser

parser = argparse.ArgumentParser(
    description="Happy l'api amie de l'AMI"
    )
parser.add_argument("--cfgfile", default="/usr/local/etc/hapimie.cfg", help="Specify a config file")
parser.add_argument("--name", default="default", help="Specify a config file")

# üß© Analyse des arguments
args,unknown = parser.parse_known_args()

# ‚ö†Ô∏è Gestion des arguments inconnus
if unknown:
    print("‚ùå Arguments inconnus :", ' '.join(unknown))
    parser.print_help()
    sys.exit(1)

if os.path.exists(args.cfgfile) and os.path.isfile(args.cfgfile):
    config= configparser.ConfigParser()
    config.optionxform=str
    config.read(args.cfgfile)
    if args.name not in config.keys():
        print(f'No {args.name} in {args.cfgfile}... OOOoooops')
        sys.exit(1)
else:
    print(f'No {args.cfgfile}.... Kouik')
    sys.exit(1)

cfg={}
cfg['API_PORT']= 8888
cfg['API_HOST']= "0.0.0.0"
cfg['AMI_HOST']= "127.0.0.1"
cfg['API_PATH']= "/api"
cfg['AMI_PORT']= 5038
cfg['AMI_USER']= "asterisk"
cfg['AMI_PASS']= "Sangoku"
cfg['MAX_RETRIES']= 3
cfg['RETRY_DELAY']= 3  # secondes
cfg['SECRET_KEY']= "supersecretkey"
cfg['ALGORITHM']= "HS256"
cfg['TOKEN_EXPIRY_HOURS']= 2
cfg['AUTHENTIK_ENABLED']= False
cfg['AUTHENTIK_TOKEN_URL']= "https://authentik.example.com/application/o/token/"
cfg['AUTHENTIK_CLIENT_ID']= "your-client-id"
cfg['AUTHENTIK_CLIENT_SECRET']= "your-client-secret"
cfg['SENTRY_DSN']=""
cfg['OIDC_CLIENT_ID']=None
cfg['OIDC_CLIENT_SECRET']=None
cfg['OIDC_ISSUER']=None
for elem in cfg.keys():
    if elem not in config[args.name]:
        continue
    cfg[elem]=config[args.name][elem]
for elem in ['API_PORT','AMI_PORT','MAX_RETRIES','RETRY_DELAY']:
    i=cfg[elem]
    cfg[elem]=int(i)
for elem in ['TOKEN_EXPIRY_HOURS']:
    i=cfg[elem]
    cfg[elem]=float(i)

if 'SENTRY_DSN' in cfg.keys() and len(cfg['SENTRY_DSN']) and 1==2:
    print("Sentry Enabling")
    import sentry_sdk

    sentry_sdk.init(
        dsn=cfg['SENTRY_DSN'],
        environment="production",
        release="hapimie@2.0",
        # Add data like request headers and IP for users,
        # see https://docs.sentry.io/platforms/python/data-management/data-collected/ for more info
        send_default_pii=True,
        )

asti=Pano(host=cfg['AMI_HOST'], port=cfg['AMI_PORT'], login=cfg['AMI_USER'], password=cfg['AMI_PASS'])

app = Zapiz(
    host=cfg['API_HOST'],
    port=cfg['API_PORT'],
    title="Hapimie",
    description="Happy l'api amie de l'AMI",
    version="0.0.3",
    docs_url="/docs",               # URL de Swagger
    redoc_url="/redoc",             # URL de Redoc
    openapi_url="/openapi.json",    # Sp√©cification OpenAPI
    oidc_client_id=cfg['OIDC_CLIENT_ID'],
    oidc_client_secret=cfg['OIDC_CLIENT_SECRET'],
    oidc_issuer=cfg['OIDC_ISSUER'],
    startup=asti.startup
    )


def home(varSession,params={}):
#, user=Depends(get_user_from_cookie)):
    print(f"üàÅ Ici on est")

    return ({'template':"welcome.html",'varSession': varSession })

#def form_view(request: Request, user=Depends(get_user_from_cookie),nom: str = None):
#def form_view(request: Request, nom: str = None):
#def form_view(varSession,*args,**kwargs):
def form_view(varSession,params={}):
    #varSession={}
    print(varSession)
    nom=params.get('nom',None)
    ret={}
    if varSession and varSession.get('nickname'):
        print(f"üéØ Auth, et cmd :{nom}")
        ret={
            "command_name": nom,
            "login": varSession["nickname"],
            "gecos": varSession["email"],
            #"sentry_dsn": cfg.get("SENTRY_DSN"),
            }
        return ({'template':"json.html",'varSession': ret })
    else:
        return({'redirect':'/login'})

#async def show_cache(request: Request,user=Depends(get_user_from_cookie),nom: str = None):
async def show_cache(request: Request,nom: str = None):
    user = request.session.get("user")
    return(cache)

##async def get_help_stx(command: str = None):
#async def get_help_stx(varSession,params={}):
#    command=params.get("command",None)
#    ret=await asti.help_stx(command)
#    return ( ret  )

#async def help_exec(request: Request,user=Depends(get_user_from_cookie),nom: str = None):
#async def help_exec(request: Request,nom: str = None):
async def api_help_exec(varSession,params={}):
    #form = await request.form()
    #user = request.session.get("user")
    data=varSession['form']

    if 'preferred_username' in varSession.keys() and 'Action' in data.keys():
        ret=await asti.action(data)
        response = {
            "Response": "Success",
            "Message": f"Commande {data['Action']} ex√©cut√©e",
            "Data": data,
            'Retour': ret
            }
    else:
        response = {
            "Response": "Failure",
            "Message": f"Non loggu√© ou pas d'action",
            "Data": data,
            'Retour': {}
            }

    return(response)

def form_help(varSession,params={}):
    return ({'template':"help.html",'varSession': varSession })

def form_endpoints(varSession,params={}):
    #return ({'template':'endpoints.html','varSession':varSession})
    return ({'template':'endpoints.html','nom':params.get('nom',""),"groupe":params.get('groupe',"")})

def form_help_detail(varSession,params={}):
    print('üîéhelp The detail')
    return({'template':'help-detail2.html',"help":params.get('nom',None)})

async def api_help(varSession,params={}):
    """
    Renvoie la doc de l'AMI
    Si on precise un parametre, c'est ce parametre sur lequel on renverra la doc
    """
    print('üÜò Help section')
    if 'command' in params.keys():
        command=params['command']
    else:
        command=None
    ret=await asti.help(command)
    return(ret)

#async def get_status(auth=Depends(get_auth_info)):
#async def get_status(request: Request):
async def api_status(varSession,params={}):
    """
    Renvoie le status.... hmmmm ca ressemble a un coreshowchannel
    """
    if not 'preferred_username' in varSession.keys():
        return({ "Channels": {}, "Phones": {}, "Caller": {} })

    ret=await asti.channels()
    ## TODO gerer les droits ici
    return(ret)

#async def hangup(request: Request,auth=Depends(get_auth_info)):
async def api_hangup(varSession,params={}):
    """
    Permet de raccrocher le channel en cours
    """
    if not 'preferred_username' in varSession.keys():
        #raise HTTPException(status_code=403)
        return(None)

    chan=params.get("channel_id",None)
    ret=await asti.channel_del(chan)
    if ret is None:
        #raise HTTPException(status_code=508)
        return(None)
    return(ret)

async def api_endpoints(varSession,params={}):
    if not 'preferred_username' in varSession.keys():
        #raise HTTPException(status_code=403)
        return(None)
    ret=await asti.endpoints()
    return(ret)

async def api_endpointPerGrp(varSession,params={}):
    if not 'preferred_username' in varSession.keys():
        #raise HTTPException(status_code=403)
        return(None)
    ret=await asti.endpointsGrp()
    return(ret)

#def ligne_view(request: Request, user=Depends(get_user_from_cookie)):
#def ligne_view(request: Request):
def form_ligne(varSession,params={}):
    refresh_interval = 1000  # en millisecondes

    if 'preferred_username' in varSession.keys():
        return ({'template':"ligne.html",'varSession': varSession,'template_data':{'refresh_interval':refresh_interval }})
    else:
        return({'redirect':'/login'})

async def api_queues(varSession,params={}):
    if not 'preferred_username' in varSession.keys():
        #raise HTTPException(status_code=403)
        return(None)
    ret=await asti.queues()
    return(ret)

#@declare_path(app,"get", f"{cfg['API_PATH']}/coreshowchannels")
#async def get_coreshowchannels():
#    """
#    Affiche les channels en cours
#    """
#    hero="CoreShowChannels"
#    return(trichan(await action(hero)))

#async def queue(request: Request, user=Depends(get_user_from_cookie)):
async def form_queues(varSession,params={}):
    """
    Affichage des queues
    """
    refresh_interval = 5000  # en millisecondes

    if 'preferred_username' in varSession.keys():
        return ({'template':"queue.html",'varSession': varSession,'template_data':{'refresh_interval':refresh_interval }})
    else:
        return({'redirect':'/login'})

async def api_dbGet(varSession,params={}):
    """
    On affiche le contenu de la db
    """
    if not 'preferred_username' in varSession.keys():
        #raise HTTPException(status_code=403)
        return(None)
    #ret=await asti._feed_db()
    key=params.get('path',None)
    ret=await asti.db_get(key)
    return(ret)


#async def dbview(request: Request, user=Depends(get_user_from_cookie)):
async def dbview(request: Request):
    """
    Affichage pour lecture, modification et suppression d'enregistrement dans la DB d'Asterisk
    """
    user = request.session.get("user")
    return templates.TemplateResponse("dbview.html", {
        "request": request,
        "login": user["login"],
        "sentry_dsn": cfg.get("SENTRY_DSN"),
        "gecos": user["gecos"]
    })

#async def db_put(request: Request,user=Depends(get_user_from_cookie)):
async def db_put(request: Request):
    form = await request.form()
    user = request.session.get("user")
    data = dict(form)
    data["Action"] = form.get("Action")

    family, key = data['Attribut'].split("/", 1)
    hero={'Action':'DbPut','family':family,'key':key,'val':data['Val']}
    if len(user['login']):
        ret=await action(hero)

        response = {
            "Response": "Success",
            "Message": f"Commande {data['Action']} ex√©cut√©e",
            "Data": data,
            "Action": hero,
            'Retour': ret
        }
        tocache('database',{},0.1)
    else:
        response = {
            "Response": "Failure",
            "Message": f"No authentification",
            "Data": data,
            "Action": hero,
            'Retour': {}
        }

    return(response)

#async def db_del(request: Request,user=Depends(get_user_from_cookie)):
async def db_del(request: Request):
    form = await request.form()
    user = request.session.get("user")
    data = dict(form)
    data["Action"] = form.get("Action")

    family, key = data['Attribut'].split("/", 1)
    hero={'Action':'DbDel','family':family,'key':key}

    if len(user['login']):
        ret=await action(hero)

        response = {
            "Response": "Success",
            "Message": f"Commande {data['Action']} ex√©cut√©e",
            "Data": data,
            "Action": hero,
            'Retour': ret
        }
        tocache('database',{},0.1)
    else:
        response = {
            "Response": "Failure",
            "Message": "No authentification",
            "Data": data,
            "Action": hero,
            'Retour': {}
        }

    return(response)

#async def get_databaseshow(user=Depends(get_user_from_cookie)):
async def get_databaseshow(request: Request):
    """
    Equivalant de "database show" dans la CLI avec suppression de familles
    Familles supprim√©es : 
        - /subscription_persistence/
        - /registrar/
        - /CustomPresence/
        - /CustomDevstate/
    """
    user = request.session.get("user")
    if len(user['login']) == 0:
        return({})

    ret=fromcache('database',{})
    if len(ret) == 0:
        hero = {"Action": "Command","command": "database show"}
        resp=await action(hero)
        ret={}
        datas=resp['Output']
        datas.pop()
        for ligne in datas:
            cmd,desc=decoupe_lexique(ligne)
            if cmd.startswith('/subscription_persistence/'):
                continue
            elif cmd.startswith('/registrar/'):
                continue
            elif cmd.startswith('/CustomPresence/'):
                continue
            elif cmd.startswith('/CustomDevstate/'):
                continue
    
            ret[cmd[1:]]=desc[2:]
        tocache('database',ret,1)
    return(ret)

#def endpoints_view(request: Request, user=Depends(get_user_from_cookie), refresh: int = 5):
def endpoints_view(request: Request, refresh: int = 5):
    """
    Affichage des endpoints
    """
    user = request.session.get("user")
    return templates.TemplateResponse("endpoints.html", {
        "request": request,
        "login": user["login"],
        "gecos": user["gecos"],
        "sentry_dsn": cfg.get("SENTRY_DSN"),
        "refresh_interval": refresh * 1000  # en millisecondes pour JS
    })

#async def get_endpoints_grps(user=Depends(get_user_from_cookie),varlf:str=None,vallf:str=None):
async def get_endpoints_grps(request: Request,varlf:str=None,vallf:str=None):
    """
    Affiche uniquement les variables des endpoints
    """
    await get_fnc_endpoints()   # En fait la fonction ne regenerera les caches que si necessaire
    user = request.session.get("user")
    varsip=fromcache(f"endpointssipvar",{})
    endpo=fromcache('endpoints',{})

    endpoints_per_var={}
    for endpoint in varsip.keys():
        if "Vars" in varsip[endpoint]:
            for var in varsip[endpoint]["Vars"].keys():
                val=varsip[endpoint]["Vars"][var]
                if not var in endpoints_per_var.keys():
                    endpoints_per_var[var]={}
                if not val in endpoints_per_var[var].keys():
                    endpoints_per_var[var][val]={}
                endpoints_per_var[var][val][endpoint]=endpo[endpoint]
    if varlf:
        if varlf in endpoints_per_var.keys():
            if vallf:
                if vallf in endpoints_per_var[varlf].keys():
                    return(endpoints_per_var[varlf][vallf])
                else:
                    return({})
            else:
                return(endpoints_per_var[varlf])
        else:
            return({})
    else:
        return(endpoints_per_var)
        

#async def get_endpoints(user=Depends(get_user_from_cookie)):
async def get_endpoints(request: Request):
    """
    Affiche tout les endpoints iax/pjsip
    """
    user = request.session.get("user")
    if len(user['login']) == 0:
        return({})
    return(await get_fnc_endpoints())

async def get_fnc_endpoints():
    """
    recupere  tout les endpoints iax/pjsip
    """
    ret=fromcache('endpoints',{})
    if isinstance(ret, int):
        return({})
    if len(ret) == 0:
        # Recuperation, sans cache de la liste de tout les endpoionts pjsip
        hero="PJSIPShowEndpoints"
        allend=await action(hero)
        # Recuperation, via cache de toutes les variables de tout les endppoints
        varsip=fromcache(f"endpointssipvar",{})
        noinitvarsip=len(varsip)
        for onened in allend:   # Boucle sur tout les postes
            ide="PJSIP/"+onened["ObjectName"]
            ret[ide]={}
            ret[ide]['ObjectName']=onened["ObjectName"]
            ret[ide]['Type']="PJSIP"
            if 'Contacts' in onened.keys() and len(onened['Contacts']):
                ret[ide]['Contacts']=re.findall(r'@(\d+\.\d+\.\d+\.\d+)',onened['Contacts'])
# "10003/sip:10003@10.37.0.239:55320;line=9xkpw9m9,10003/sip:10003@10.37.0.239:55320;line=mgpu4zc1,"
# "antoine/sip:antoine@192.168.0.239:55320;line=9xkpw9m9,antoine/sip:antoine@192.168.0.92:55320;line=mgpu4zc1,"
# "192.168.0.239" et "192.168.0.92"
            ret[ide]['Up']=True
            if onened['DeviceState']=="Unavailable":
                ret[ide]['Up']=False
            if ide not in varsip:
                hero={"Action":"PJSIPShowEndpoint","Endpoint":onened["ObjectName"]}
                tmp=await action(hero)
                if 'SetVar' in tmp[0].keys() and len(tmp[0]['SetVar']):
                    noinitvarsip=0
                    varsip[ide]={}
                    varsip[ide]['Vars']={}
                    for ligne in tmp[0]['SetVar'].split(','):
                        k,v=ligne.split('=',1)
                        varsip[ide]['Vars'][k]=v
                else:
                    varsip[ide]={}
            ret[ide]['SetVar']=varsip[ide]
            ret[ide]['Full']=onened
            if not noinitvarsip:    # Si on considere qu'il faut ecraser le cache...
                tocache(f"endpointssipvar",varsip,600)
 
        hero="IAXpeerlist"
        allend=await action(hero)
        for onened in allend:
            ide="IAX2/"+onened["ObjectName"]
            ret[ide]={}
            ret[ide]['ObjectName']=onened["ObjectName"]
            ret[ide]['Type']="IAX2"
            if onened['IPaddress']=="(null)":
                ret[ide]['Contacts']=onened['IPaddress']
            ret[ide]['Up']=True
            if onened['Status']=="UNKNOWN":
                ret[ide]['Up']=False
            ret[ide]['Full']=onened
        tocache('endpoints',ret,3)
    return(ret)


#async def dial_page(request: Request, login=Depends(get_user_from_cookie)):
async def dial_page(request: Request):
    user = request.session.get("user")
    return templates.TemplateResponse("dial.html", {
        "request": request,
        "sentry_dsn": cfg.get("SENTRY_DSN"),
        "login": login['login']
    })

#async def get_myphones(user=Depends(get_user_from_cookie)):
async def get_myphones(request: Request):
    # Exemple statique ‚Äî √† remplacer par une vraie source
    user = request.session.get("user")
    if len(user['login']) == 0:
        return([])

    return ["10012", "1002", "_"]

async def showtrack(request: Request):
    user = request.session.get("user")
    data = await request.json()
    if len(user['login']) == 0:
        return({})
    return(trackeurAMI)

#async def dial_api(request: Request, user=Depends(get_user_from_cookie)):
async def dial_api(request: Request):
    data = await request.json()
    user = request.session.get("user")
    appellant = data.get("appellant")
    numero = data.get("numero")
    if len(user['login']) == 0:
        return {"status": "KO", "login": user['login'], "appellant": appellant, "numero": numero}
    ti=f'{appellant}-{numero}'
    if ti in trackeurAMI['Originate'].keys():
        print("Oulla c'est le dawa je ne sais pas encore gerer les bis,alors je raccrocerais l'autre et je relancerais")
        print(f"Va falloire couper ca : {trackeurAMI['Originate'][ti]['Channel']}")
    ti=f'Hapimie-{appellant}-{numero}-{time()}'
    trackeurAMI['Originate'][ti]={}
    hero = {'Action': 'Originate','Channel': f'Local/{appellant}@internal', 'Exten': numero, 'Context': 'internal', 'Priority': 1, 'CallerId':f'Mon ami {appellant}', 'Async':'false','ChannelId': ti }
    ret=await action(hero)
    pprint(ret)
    
    sleep(2)
    print("show nous le trackeur impitoyable")
    print(trackeurAMI['Originate'][ti])
    if ti in trackeurAMI['Originate'].keys():
        cha=trackeurAMI['Originate'][ti]

    return {"status": ret['Response'], "login": user['login'], "appellant": appellant, "numero": numero, 'full':ret, 'channel': cha}

def funNull(varSession=None,params=None):
    1

webFunc=[
    ("/",home),
    ("/json",form_view),
    ("/json/",form_view),
    ("/json/{nom}",form_view),
    ("/help",form_help),
    ("/help/{nom}",form_help_detail),
    ("/ligne",form_ligne),
    ("/endpoints",form_endpoints),
    ("/endpoints/{nom}",form_endpoints),
    ("/endpoints/{nom}/{groupe}",form_endpoints),
    ("/queue",form_queues),
#    ("/queue", queue),
#    ("/dbview",dbview),
#    ("/endpoints", endpoints_view),
#    ("/dial", dial_page),
    ("/favicon.ico",funNull),
    ]
apiFunc=[
    (f"{cfg['API_PATH']}/help",api_help),
    (cfg['API_PATH']+"/help/{command}",api_help),
    (f"{cfg['API_PATH']}/status",api_status),
    (f"{cfg['API_PATH']}/queue",api_queues),
#    (f"{cfg['API_PATH']}/queue/",get_queue),
#    (cfg['API_PATH']+"/queue/{queue}",get_queue),
#    (f"{cfg['API_PATH']}/databaseshow",get_databaseshow),
#    (f"{cfg['API_PATH']}/endpoints_grps",get_endpoints_grps),
#    (cfg['API_PATH']+"/endpoints_grps/{varlf}",get_endpoints_grps),
#    (cfg['API_PATH']+"/endpoints_grps/{varlf}/{vallf}",get_endpoints_grps),
    (f"{cfg['API_PATH']}/endpoints",api_endpoints),
    (f"{cfg['API_PATH']}/endpointPerGrp",api_endpointPerGrp),
    (f"{cfg['API_PATH']}/dbGet",api_dbGet),
    (f"{cfg['API_PATH']}/dbGet/"+"{path:path}",api_dbGet),
#    (f"{cfg['API_PATH']}/myphones",get_myphones),
#    (f"{cfg['API_PATH']}/trackeur",showtrack),
    ]
apiPostFunc=[
    (cfg['API_PATH']+"/help-exec",api_help_exec), #POST
    (cfg['API_PATH']+"/HangUp",api_hangup), # POST
#    (cfg['API_PATH']+"/dbPut",db_put), # POST
#    (cfg['API_PATH']+"/dbDel",db_del), # POST
#    (f"{cfg['API_PATH']}/dial",dial_api), # POST
    ]


for route,func in webFunc:
    app.api(route,func)

for route,func in apiFunc:
    app.api(route,func,html=False)

for route,func in apiPostFunc:
    app.api(route,func,html=False,verb="post")


##########################################################################################

#if __name__ == "__main__":
#    import uvicorn
#    app.add_middleware(
#        CORSMiddleware,
#        allow_origins=["*"],  # ou ["http://localhost:3000"]
#        allow_credentials=True,
#        allow_methods=["*"],
#        allow_headers=["*"],
#        )
#    uvicorn.run(app, host=cfg['API_HOST'], port=cfg['API_PORT'])

app.run()
